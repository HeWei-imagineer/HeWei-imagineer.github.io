<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hw</title>
  <icon>https://www.gravatar.com/avatar/4f5337bf0e4c5a473c5d93e50ac0c3d5</icon>
  <subtitle>静若处子，动若脱兔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-10T04:10:53.833Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hw</name>
    <email>summer.vv@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git</title>
    <link href="http://yoursite.com/2018/08/10/git/"/>
    <id>http://yoursite.com/2018/08/10/git/</id>
    <published>2018-08-10T03:53:30.000Z</published>
    <updated>2018-08-10T04:10:53.833Z</updated>
    
    <content type="html"><![CDATA[<p>git </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git &lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react-life</title>
    <link href="http://yoursite.com/2018/08/08/react-life/"/>
    <id>http://yoursite.com/2018/08/08/react-life/</id>
    <published>2018-08-08T15:48:14.000Z</published>
    <updated>2018-08-09T02:00:18.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-异步请求"><a href="#react-异步请求" class="headerlink" title="react 异步请求"></a>react 异步请求</h1><p><img src="/assets/filter.png" width="500"><br><img src="/assets/list.png" width="500"></p><p>首先页面结构为</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function reportState(state)&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    teamListData: state.SetTeam.toJS()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(reportState, actions)(BattleTeamFilter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function reportState(state)&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    teamListData: state.SetTeam.toJS()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(reportState, actions)(BattleTeamList)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const reportState = (state) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    teamListData: state.SetTeam.toJS()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default connect(reportState, actions)(SetTeam)</span><br></pre></td></tr></table></figure><p>如上图，点击更换组长之后，需要连续发送请求，更新list内容。解决方案：</p><ol><li><p>点击更换组长的按钮时触发函数，将this指针传递给action，action里dispatch查询数据的函数。很hack，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export const delMemberByCode = (url, params, _me) =&gt; (dispatch, getState) =&gt; &#123;</span><br><span class="line">  Request(&#123;</span><br><span class="line">    url,</span><br><span class="line">    params</span><br><span class="line">  &#125;).then((data)=&gt;&#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type:&apos;setListNull_setTeam&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    let orgCode = _me.props.teamListData.orgCode</span><br><span class="line">    let currentPage = _me.props.teamListData.currentPage</span><br><span class="line">    _me.props.queryTeamList(Api.battleTeam.queryTeamList, &#123;orgCode, currentPage, pageSize: 10&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在action里dispatch一个新的动作，更改外部state的维护值，在接受新的props时，触发componentWillReceiveProps从而再次发送新的请求，显示数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var initState = &#123;</span><br><span class="line">    ...</span><br><span class="line">  _num: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &apos;DELETE_RULECENTER_LIST_SUCCESS&apos;:</span><br><span class="line">            return state.set(&apos;_num&apos;, ++initState._num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">componentWillReceiveProps(newprop) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      filter: newprop.ruleData.filter</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h1><p><img src="/assets/react_life.jpg" width="500"><br>可以看到，</p><ol><li>redux通过componentWillReceiveProps()函数接入，传入props改变触发shouldComponentUplate，当shouldComponentUplate函数返回true时，接着会调用componentWillUplate，render，componentDidUpdate。若shouldComponentUplate函数返回false时，不会触发组件的渲染。</li><li>而组件自己内部的this.state改变时会触发shouldComponentUplate函数，之后流程一样。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react-异步请求&quot;&gt;&lt;a href=&quot;#react-异步请求&quot; class=&quot;headerlink&quot; title=&quot;react 异步请求&quot;&gt;&lt;/a&gt;react 异步请求&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/assets/filter.png&quot; width=&quot;500&quot;&gt;&lt;br&gt;&lt;img src=&quot;/assets/list.png&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先页面结构为&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>solution</title>
    <link href="http://yoursite.com/2018/08/03/solution/"/>
    <id>http://yoursite.com/2018/08/03/solution/</id>
    <published>2018-08-03T09:19:50.000Z</published>
    <updated>2018-08-08T02:08:38.773Z</updated>
    
    <content type="html"><![CDATA[<ol start="13"><li><p>import React from ‘react’;</p><blockquote><p>由于 JSX 编译后会调用 React.createElement 方法，所以在你的 JSX 代码中必须首先声明 React 变量。</p></blockquote></li><li><p>JSX语法<br>点表示法：从一个模块中导出多个React组件 </p><a id="more"></a></li></ol><p><code>return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;</code><br>首字母大写：会将小写开头的标签名认为是 HTML 原生标签</p><blockquote><p>当元素类型以小写字母开头时，它表示一个内置的组件，如 <div> 或 <span>，并将字符串 ‘div’ 或 ‘span’ 传 递给 React.createElement.(这句话是什么意思) 以大写字母开头的类型，如 <foo> 编译为 React.createElement(Foo),</foo></span></div></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Hello() &#123;</span><br><span class="line">  return &lt;div&gt;Hello world!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">  return &lt;Hello&gt;</span><br><span class="line">  hello&lt;/Hello&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Hello() &#123;</span><br><span class="line">  return React.createElement(</span><br><span class="line">    &quot;div&quot;,</span><br><span class="line">    null,</span><br><span class="line">    &quot;Hello world!&quot;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">  return React.createElement(</span><br><span class="line">    Hello,</span><br><span class="line">    null,</span><br><span class="line">    &quot;hello&quot;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件的props.children</p>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;13&quot;&gt;
&lt;li&gt;&lt;p&gt;import React from ‘react’;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于 JSX 编译后会调用 React.createElement 方法，所以在你的 JSX 代码中必须首先声明 React 变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JSX语法&lt;br&gt;点表示法：从一个模块中导出多个React组件 &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8.3</title>
    <link href="http://yoursite.com/2018/08/03/8-3/"/>
    <id>http://yoursite.com/2018/08/03/8-3/</id>
    <published>2018-08-03T03:35:12.000Z</published>
    <updated>2018-08-07T10:43:23.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题总结："><a href="#问题总结：" class="headerlink" title="问题总结："></a>问题总结：</h1><ol><li>了解组件的整个生命周期，什么时候创建，什么时候接收外部的props，什么时候渲染，setState的时候如何触发render函数以及状态的异步更新。</li><li>向组件传递函数时，this不会自动绑定，原因解决方案 <code>onClick={this.reset.bind(this)}</code></li><li>建立Provider, 传递参数store, 组件是如何绑定相对应的state</li><li>js模块化管理，commonJS</li><li>react路由</li></ol><a id="more"></a><ol start="6"><li>redux中间件, subscribe具体订阅的内容</li><li>异步action</li><li>propTypes</li><li>Windows.location</li><li>ajax请求, 浏览器缓存</li><li><p>react-redux源码</p></li><li><p>对代码的管理：如何管理自己所有的代码。如果在一个项目中，想抽取自己完成的部分做一个整合，但剥离之后发现代码无法独立完成自己的功能。那我该整合的是什么？</p></li><li>Url 改变后, 无法正常展示页面<br>解决：import React from ‘react’  !!!</li><li>Redux如何整合这些状态和reducer，文件时如何被编译的</li><li>dispatch函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">me.props.dispatch(actions.violationBehavior(listData))；</span><br><span class="line">export const violationBehavior = (params) =&gt; dispatch =&gt; &#123;</span><br><span class="line">  fetch(API.violationBehavior,&#123;</span><br><span class="line">    method:&apos;get&apos;,</span><br><span class="line">    params:params,</span><br><span class="line">    mock: false</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(result =&gt; &#123;</span><br><span class="line">    if(result.data.code == 0)&#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: &apos;GET_VIOLATIONBEHAVIOR&apos;,</span><br><span class="line">        res: result.data.data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="16"><li>组件 this.props是指向了原想对象上的属性吗？</li><li>key</li><li>ref</li><li>.git hook文件</li><li>JSX语法解析，插入的字符串模版何时解析。按react写法还是html写法。<br>解析后会不会再按JSX解析<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const showLabel = (label) =&gt; &#123;</span><br><span class="line">        let result = [];</span><br><span class="line">        label.forEach( (item) =&gt; &#123;</span><br><span class="line">            result += `&lt;Button&gt;$&#123;item&#125;&lt;/Button&gt;`;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const text = showLabel(label);</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">    const &#123; getFieldDecorator &#125; = this.props.form;</span><br><span class="line">    const formItemLayout = &#123;</span><br><span class="line">      labelCol: &#123; span: 6 &#125;,</span><br><span class="line">      wrapperCol: &#123; span: 14 &#125;,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li></ol><p>知识总结：</p><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><ol><li>利用prop传递值。<component prop="{}">.   渲染的时候可以使用该值，其实就是为接收外部数据提供一个接口，传值方式：<br>Function: props.<em><br>Class: this.props.</em></component></li><li>用属性的方式绑定函数</li><li>变量提升，父组件存子组件状态，再把状态通过prop传给子组件；子组件可以通过父组件传来的函数改变父组件状态。把属性和操作提升到父组件，在分发给子组件</li><li>变量不变性。不要直接修改变量的，用新变量替换老变量</li><li>组件命名开头字母大写，props为只读，setState会触发渲染</li><li>react就是创建虚拟DOM，简化渲染<br>redux</li><li>Redux 维护一个store，用dispatch（state，action）触发reducer，subscride渲染组件</li><li>Store不可直接修改，可以更新；reducer为纯函数</li><li>和react结合时，本质就是处理好，redux的store与react组件state的关系</li><li>表示组件：只负责渲染样式<br>容器组件：通过connect（mapStateToProps, DispatchToProps）函数，<br>mapStateToProps: 将store中的数据连接组件，<br>DispatchToProps: 将action做为props绑定到组件上。</li></ol><h2 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h2><ol><li>用reducer初始化state</li><li>当增强dispatch函数时：<br>在函数前后加一些操作，是的，每个人都能这样做，但代码毫无复用行。<br>按不同需求，封装出新的模块，包含增强操作和dispatch函数，在需要他的地方替换。<br>再想想，直接返回dispatch（），返回一个函数，就是改装了一下dispatch，换个名字，还是一样的用法<h2 id="dva"><a href="#dva" class="headerlink" title="dva"></a>dva</h2><blockquote><p>组合了react + redux + saga.  Model语法，整合了action，state，reducer。加入了effect，subsctiptions。<br>组件，connect做了reat组件和redux的结合，router</p></blockquote></li></ol><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><ol><li>同源策略（浏览器安全的基石）：协议相同，域名相同，端口相同.<br>非同源下的行为限制：cookie，localstorage，indexDB无法读取；DOM无法获得；AJAX请求无法发送<br>解决方案：<br>AJAX：请求只发给同源网址。打破限制：<br>JSONP: 在网页动态插入js脚本（异步加载，防阻塞），src：放置请求，利用src跨域请求。服务器收到请求后把数据放在回调函数的参数位置。只能是get请求<br>WebSocket: 使用ws://, was://协议，通过对origin字段的判断，决定是否允许该请求执行。</li></ol><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><ol><li>Clone<br>git clone git://example.com/path/to/repo.git/</li><li>Remote<br>Git remote -v 查看网址<pre><code>show 查看详细信息</code></pre></li><li>git fetch<br>取回更新</li><li>git pull = git fetch + git merge.<br>Git pull origin  next:master 从远程主机 的next分支和本地的master分支合并<br>建立追踪，git branch —set-upstream master origin/next  本地master 分支追踪远程主机origin分支next，建立追踪后可直接。git pull origin</li></ol><p>Git pull/push origin &lt;源&gt;&lt;目的地&gt;/&lt;目的地&gt;&lt;源&gt;</p><ol start="5"><li>git push<br>所以：切分支，合并，推送<br>Push之前先pull</li></ol><h2 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h2><ol><li>解构赋值： 对象解构赋值<br>let { foo: bar } = { foo: “aaa”, bar: “bbb” };<br>foo是匹配模式，bar是变量, 结果是：变量bar的值为：‘aaa’</li><li><p>dva中分页插件的使用： </p><blockquote><p>component/user.js ：通过mapStateToProps将插件绑定到组件上，流到组件里。<br>index.js: 使用插件，import插件，添加 app.model(require(‘./models/users’));<br><code>https://github.com/sorrycc/blog/issues/18</code></p></blockquote></li><li><p>mac下sublime快捷键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Shift+K:删除整行</span><br><span class="line">Ctrl+command+g：选中所有相同文本</span><br><span class="line">Ctrl+D: 选中相同内容； Ctrl+U: 回退选中的内容</span><br></pre></td></tr></table></figure></li></ol><p>clect loaderble<br>周会分享：</p><p>过程，故事化，不要多，一个点就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题总结：&quot;&gt;&lt;a href=&quot;#问题总结：&quot; class=&quot;headerlink&quot; title=&quot;问题总结：&quot;&gt;&lt;/a&gt;问题总结：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;了解组件的整个生命周期，什么时候创建，什么时候接收外部的props，什么时候渲染，setState的时候如何触发render函数以及状态的异步更新。&lt;/li&gt;
&lt;li&gt;向组件传递函数时，this不会自动绑定，原因解决方案 &lt;code&gt;onClick={this.reset.bind(this)}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;建立Provider, 传递参数store, 组件是如何绑定相对应的state&lt;/li&gt;
&lt;li&gt;js模块化管理，commonJS&lt;/li&gt;
&lt;li&gt;react路由&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8.2</title>
    <link href="http://yoursite.com/2018/08/02/8-2/"/>
    <id>http://yoursite.com/2018/08/02/8-2/</id>
    <published>2018-08-02T06:55:35.000Z</published>
    <updated>2018-08-02T09:54:03.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="another-day"><a href="#another-day" class="headerlink" title="another day"></a>another day</h1><p>how to handle my life. when I use react and redux, I realize the importance of detail. </p><p>props.param.id: 可以拿到路由参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;another-day&quot;&gt;&lt;a href=&quot;#another-day&quot; class=&quot;headerlink&quot; title=&quot;another day&quot;&gt;&lt;/a&gt;another day&lt;/h1&gt;&lt;p&gt;how to handle my life. when I use 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>8.1</title>
    <link href="http://yoursite.com/2018/08/01/8-1/"/>
    <id>http://yoursite.com/2018/08/01/8-1/</id>
    <published>2018-08-01T04:21:16.000Z</published>
    <updated>2018-08-08T02:07:37.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js-函数柯里化"><a href="#js-函数柯里化" class="headerlink" title="js 函数柯里化"></a>js 函数柯里化</h1><p>call apply bind<br>apply: function.call(thisArg, [arg1, arg2, …]) 传数组参数<br>call: function.call(thisArg, arg1, arg2, …)    传单个参数<br>bind: function.call(thisArg, arg1, arg2, …)    不改变原函数，返回一个新函数</p><a id="more"></a><p>let curring = function f(a) {<br>                return f1 (b) {<br>                    return f2 (c) {<br>                        return f3 (d)<br>                    }<br>                }<br>            }<br>so I can use this by this way:</p><p>let B = curring(a)<br>let C = B(b)<br>let D = C(c)<br>let result = D(d)<br>就像是函数装饰器一样，为一个简单的函数增加了很多处理。也可以用箭头函数表示：<br>    let add = a =&gt; b =&gt; a + b<br>    var add3 = add(3)<br>    add3(4) === 3 + 4 //true</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;js-函数柯里化&quot;&gt;&lt;a href=&quot;#js-函数柯里化&quot; class=&quot;headerlink&quot; title=&quot;js 函数柯里化&quot;&gt;&lt;/a&gt;js 函数柯里化&lt;/h1&gt;&lt;p&gt;call apply bind&lt;br&gt;apply: function.call(thisArg, [arg1, arg2, …]) 传数组参数&lt;br&gt;call: function.call(thisArg, arg1, arg2, …)    传单个参数&lt;br&gt;bind: function.call(thisArg, arg1, arg2, …)    不改变原函数，返回一个新函数&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>dva</title>
    <link href="http://yoursite.com/2018/07/29/dva/"/>
    <id>http://yoursite.com/2018/07/29/dva/</id>
    <published>2018-07-29T15:41:05.000Z</published>
    <updated>2018-08-07T10:37:47.334Z</updated>
    
    <content type="html"><![CDATA[<p>dva就完全是一个react + redux + redux-saga的包装框架，配合了umi使用<br>规范处理，基本用相同的模式生成应用，开发者只需要在相应的地方填入代码即可</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 1.initialize</span><br><span class="line">const app = dva();</span><br><span class="line"> </span><br><span class="line">// 2. model 关键</span><br><span class="line">// 这里些组件的state; reducer函数; *effects，异步处理数据的函数，一般是后端返回的数据</span><br><span class="line">app.model(&#123;</span><br><span class="line">  namespace: &apos;content&apos;,</span><br><span class="line">  state: &apos;00:00&apos;,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    dateShow () &#123; </span><br><span class="line">      let date = new Date();</span><br><span class="line">      return date.toLocaleTimeString()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 组件, 写拿到state数据之后的对数据的处理</span><br><span class="line">const dateShow = (props) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;It is &#123;props.content&#125; &lt;/span&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; &#123;props.dispatch(&#123;type: &apos;content/dateShow&apos;&#125;)&#125;&#125;&gt;refresh&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. view</span><br><span class="line"></span><br><span class="line">const App = connect((&#123; content &#125;) =&gt; (&#123; content &#125;))(dateShow)</span><br><span class="line"></span><br><span class="line">// 4. Router</span><br><span class="line">app.router(() =&gt; &lt;App /&gt;);</span><br><span class="line"></span><br><span class="line">// 5. Start</span><br><span class="line">app.start(&apos;#root&apos;);</span><br></pre></td></tr></table></figure><p>基本结构：src &gt; component/ + model/ + service/ + utils/<br>实际应用在项目中时，能顺利建立起一个页面，便可以基本使用该框架了。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dva就完全是一个react + redux + redux-saga的包装框架，配合了umi使用&lt;br&gt;规范处理，基本用相同的模式生成应用，开发者只需要在相应的地方填入代码即可&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redux-demo</title>
    <link href="http://yoursite.com/2018/07/29/redux-demo/"/>
    <id>http://yoursite.com/2018/07/29/redux-demo/</id>
    <published>2018-07-29T05:14:02.000Z</published>
    <updated>2018-08-08T01:44:24.676Z</updated>
    
    <content type="html"><![CDATA[<p>redux: 对于数据的一种管理方式<br>如果数据来源不仅仅是与用户的交互还有网络端，各组件之间通信频繁，很多组件要访问同一个在变化的数据。这时候就应该建立起对数据统一的管理方式。</p><a id="more"></a><p>不再让数据随意流。每一瞬间获取的state都是唯一的，规范化地处理函数(定义action，说明如何改变数据，即说明动作)，规范化地改变状态(通过connect和dispatch，完成数据与视图的绑定还有动作的触发)，但数据如何绑定组件还是由开发者决定。<br>以下实例为点击按钮，将页面上的数字加1.<br>按照之前的步骤会这样建立程序：<br>数据处理handleData =&gt; 组件设计，页面布局,render函数的构建 =&gt; 决定在哪里setState以及从哪里拿数据。对比如下的例子：</p><ol><li>定义action，这是对数据处理的预说明；reducer，数据处理的方式 </li></ol><!-- more --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// action：定义type表示操作类型</span><br><span class="line">let counter = 0;</span><br><span class="line"></span><br><span class="line">export const Increment = () =&gt; (&#123;</span><br><span class="line">    type: &apos;ADD_ONE&apos;,</span><br><span class="line">    counter: counter++</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const newContent = text =&gt; (&#123;</span><br><span class="line">    type: &apos;NEW_CONTENT&apos;,</span><br><span class="line">    text: text</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* reducer可以使用combineReducers简化。把部分state的值传给reducer，子reducer可以返回默认值。每一部分的reducer只关注部分state的更新，处理每一个属性，合成，combineReducer来处理。combineReducer函数传入一个对象。&#123;state的一个值，值的名字：函数.&#125; 最后reducer return a object</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 可以在reducer函数里定义state默认值</span><br><span class="line">function changeText(state=&apos;Hello,Echo&apos;, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;NEW_CONTENT&apos;:</span><br><span class="line">            return action.text;</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function counter(state=0, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &apos;ADD_ONE&apos;:</span><br><span class="line">            return action.counter;</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &#123;state的一个值，值的名字：函数.&#125;，当属性值与reducer函数名相同时，可以简写为&#123;text, counter&#125;</span><br><span class="line">const App = combineReducers(&#123;</span><br><span class="line">    text: changeText,</span><br><span class="line">    counter: counter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>定义组件，这里有纯组件和容器组件。纯组件只负责展示，容器组件会绑定数据，这里就是react和redux的结合。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; value, addOne &#125; = this.props;</span><br><span class="line">        return (</span><br><span class="line"></span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123; value.text &#125;&lt;/h2&gt;</span><br><span class="line">                &lt;span&gt;&#123; value.counter &#125;&lt;/span&gt;</span><br><span class="line">                &lt;button onClick=&#123; addOne &#125;&gt; Increment &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不涉及该例子，仅做补充说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 将属性传递给组件</span><br><span class="line">const mapStateToProps = state =&gt; (&#123;</span><br><span class="line">  todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 将触发处理的函数传递给函数</span><br><span class="line">const mapDispatchToProps = dispatch =&gt; (&#123;</span><br><span class="line">  toggleTodo: id =&gt; dispatch(toggleTodo(id))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 这里把组件，数据，处理绑定到一起，同时对组件做了一个订阅(可以自定义使用 store.subscribe，当dispatch的时候会触发组件的render</span><br><span class="line">export default connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure></p><p>所以我们采用了静态定义action，使用reducer返回一个新的state，dispatch触发reducer，通过以上三个点完成对数据的处理；静态组件完成布局；动态组件负责数据处理到组件的绑定。<br>后续还有redux中间件,React-Router和异步操作等内容，待更新…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;redux: 对于数据的一种管理方式&lt;br&gt;如果数据来源不仅仅是与用户的交互还有网络端，各组件之间通信频繁，很多组件要访问同一个在变化的数据。这时候就应该建立起对数据统一的管理方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react-demo</title>
    <link href="http://yoursite.com/2018/07/27/react-demo/"/>
    <id>http://yoursite.com/2018/07/27/react-demo/</id>
    <published>2018-07-27T08:45:25.000Z</published>
    <updated>2018-08-08T01:44:22.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-demo"><a href="#react-demo" class="headerlink" title="react-demo"></a>react-demo</h1><p>功能：在组件挂载时设置定时器，卸载时解除定时器。点击按钮刷新页面信息。</p><p>react想要做的就是让dom活起来。dom随数据而变化，我想叫他变量的可视化。开发人员不再过多关注已有的dom树，从树里定位元素，插入值。现在当我想展示一件事物时，我只用关心它核心的数据，配个组件使用，就能描绘出他的全貌。以之前提及的tac-tic-toe为例。{histor: [state1, state2, state3]}, 利用这一个数据，我就可以展示棋盘状态，记录步骤。加上isNext，stepNumber就能实现交替落子，步骤回退。</p><a id="more"></a><p>回到react之前，实现tac-tic-toe例子时，我会先搭建html框架，js处理完数据后，再去操作dom。虽然这样看起来似乎比较清晰，但是我更喜欢react的组织方式。它更接近我自己脑海里建立起的编程思想。对于后端程序来说每一个变量都是存在电门里的电信号，而在前端，每一个变量在被处理后会有两个选择：1，经浏览器解析，变成DOM在页面显示; 2.还是变成电信号被存储起来。react的工作就是把变量转化为dom。下面是一个简单的小例子：</p><p>使用mock数据<br><code>npm install mockjs</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Mock = require(&apos;mockjs&apos;);</span><br><span class="line">var Random = Mock.Random;</span><br><span class="line">Random.sentence(3, 5)</span><br></pre></td></tr></table></figure><!-- more --><ol><li><p>生命周期函数<br>react在转化为真正的dom的时候会经历很多阶段，在一些阶段里提供了接口供开发者使用，以下是组件挂载和卸载时调用的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">        this.timerID = setInterval(</span><br><span class="line">            () =&gt; this.tick(),</span><br><span class="line">            1000</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">        clearInterval(this.timerID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>处理函数：<br>每个组件里都可以定义处理函数，实现与用户的交互，还有就是对数据进行处理。这里就是我所理解的编程思想。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 生成时间函数</span><br><span class="line">tick() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            date: new Date()</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">handleClick(props) &#123;</span><br><span class="line">        // 这里推荐传入函数，把先前的状态作为第一个参数出纳入，因为this.state可能是异步更新</span><br><span class="line">        </span><br><span class="line">        // fetch ( api, &#123;</span><br><span class="line">        //     headers: &#123;</span><br><span class="line">        //         &apos;content-type&apos;: &apos;application/x-www-form-urlencoded&apos;</span><br><span class="line">        //     &#125;</span><br><span class="line">        // &#125;).then(response =&gt;</span><br><span class="line">        //     response.json()</span><br><span class="line">        // ).then(res =&gt; &#123; </span><br><span class="line">        //     // debugger</span><br><span class="line">        //     console.log(res)</span><br><span class="line">        //     this.setState(&#123;</span><br><span class="line">        //         text: res</span><br><span class="line">        //     &#125;);</span><br><span class="line"></span><br><span class="line">        //  &#125;)</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">                text: Mock.mock(&apos;@sentence(3, 5)&apos;)</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>渲染函数<br>react神奇的JSX语法(让组件变量化的关键)，在这里进行的工作就是实现数据与组件的绑定以及决定如何展示数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">        return ( &lt;</span><br><span class="line">            div className=&#123;styles.container&#125;&gt;</span><br><span class="line">            &lt;</span><br><span class="line">            h2 &gt; &#123; this.state.date.toLocaleTimeString() &#125;. &lt; /h2&gt;  &lt;</span><br><span class="line">            h1 &gt; &#123; this.state.text &#125; &lt; /h1&gt;  &lt;</span><br><span class="line">            Button name = &apos;send&apos;</span><br><span class="line">            onClick = &#123;</span><br><span class="line">                (props) =&gt; &#123;</span><br><span class="line">                    console.log(&apos;click事件&apos;, props)</span><br><span class="line">                    this.handleClick(props)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            /&gt; &lt;</span><br><span class="line">            /div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>好,现在我们可以回顾一下,用react实现实时显示时间,点击一个按钮刷新页面内容的小应用经历了哪些步骤:</p><ol><li>首先我考虑的是数据的处理,这里需要new一个新的Date(), 并设置一个定时器函数;其次是随机生成的字符串。</li><li>其次是数据可视化。一个面板组件，左上角放时间，中间是随机生成的字符串和一个button。</li><li>*最后是数据到组件的绑定方式。这里是关键。设置定时器函数完成实时显示时间功能，在组件挂载时绑定，组件卸载时取消。在button的click事件上绑定刷新内容的函数。<br>综上：<br> 数据处理handleData =&gt; 组件设计，页面布局,render函数的构建 =&gt; 决定在哪里setState<br>最后，我觉得最关键的就是与用户交互时对数据的处理, 数据可视化,</li></ol><p>思维总是虚无缥缈，实践见真知</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react-demo&quot;&gt;&lt;a href=&quot;#react-demo&quot; class=&quot;headerlink&quot; title=&quot;react-demo&quot;&gt;&lt;/a&gt;react-demo&lt;/h1&gt;&lt;p&gt;功能：在组件挂载时设置定时器，卸载时解除定时器。点击按钮刷新页面信息。&lt;/p&gt;
&lt;p&gt;react想要做的就是让dom活起来。dom随数据而变化，我想叫他变量的可视化。开发人员不再过多关注已有的dom树，从树里定位元素，插入值。现在当我想展示一件事物时，我只用关心它核心的数据，配个组件使用，就能描绘出他的全貌。以之前提及的tac-tic-toe为例。{histor: [state1, state2, state3]}, 利用这一个数据，我就可以展示棋盘状态，记录步骤。加上isNext，stepNumber就能实现交替落子，步骤回退。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>note</title>
    <link href="http://yoursite.com/2018/06/04/note/"/>
    <id>http://yoursite.com/2018/06/04/note/</id>
    <published>2018-06-04T12:00:10.000Z</published>
    <updated>2018-08-08T01:44:15.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h1><p>Get vs Post : </p><ol><li>get put data in url; post: put data in https body (it can modified data)</li></ol><a id="more"></a><p><code>&lt;input name=&quot;&quot; placeholder=&quot;&quot; autofocus=&quot;&quot;&gt;:</code><br>‘name’ is the key of send message</p><h1 id="URL编码规范"><a href="#URL编码规范" class="headerlink" title="URL编码规范"></a>URL编码规范</h1><p>转义:  ! =&gt; 21%</p><h1 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h1><p>why, why is there http method</p><p>I want to buid a website to record my life.<br>It more than a normal web page, but there are some interstinf part.</p><ol><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Form&quot;&gt;&lt;a href=&quot;#Form&quot; class=&quot;headerlink&quot; title=&quot;Form&quot;&gt;&lt;/a&gt;Form&lt;/h1&gt;&lt;p&gt;Get vs Post : &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;get put data in url; post: put data in https body (it can modified data)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js事件机制</title>
    <link href="http://yoursite.com/2018/05/28/js%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/05/28/js事件机制/</id>
    <published>2018-05-28T13:29:48.000Z</published>
    <updated>2018-08-08T00:30:23.301Z</updated>
    
    <content type="html"><![CDATA[<p>已知</p><ol><li>事件定义，监听</li><li>事件封装，触发<br>未知</li><li>如何定义当前target</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已知&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事件定义，监听&lt;/li&gt;
&lt;li&gt;事件封装，触发&lt;br&gt;未知&lt;/li&gt;
&lt;li&gt;如何定义当前target&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>EnglishLearning</title>
    <link href="http://yoursite.com/2018/05/28/EnglishLearning/"/>
    <id>http://yoursite.com/2018/05/28/EnglishLearning/</id>
    <published>2018-05-28T00:46:32.000Z</published>
    <updated>2018-08-08T00:30:23.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Listening"><a href="#Listening" class="headerlink" title="Listening"></a>Listening</h2><ol><li>单词：没有建立起单词和词音的联系；（听音记单词）</li><li>表达方式：不熟悉含有大量介词，代词，从句的表达方式；（系统学习语法）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Listening&quot;&gt;&lt;a href=&quot;#Listening&quot; class=&quot;headerlink&quot; title=&quot;Listening&quot;&gt;&lt;/a&gt;Listening&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;单词：没有建立起单词和词音的联系；（听音记单词）&lt;/li&gt;
&lt;li&gt;表达
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>summary</title>
    <link href="http://yoursite.com/2018/05/25/summary/"/>
    <id>http://yoursite.com/2018/05/25/summary/</id>
    <published>2018-05-25T02:34:03.000Z</published>
    <updated>2018-08-08T02:07:31.749Z</updated>
    
    <content type="html"><![CDATA[<p>It’s time to look back. I must learn to control my life, rather than walk numbly just like a zombie. Never forget why you choose the way.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;It’s time to look back. I must learn to control my life, rather than walk numbly just like a zombie. Never forget why you choose the way.
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>note3</title>
    <link href="http://yoursite.com/2018/03/21/note3/"/>
    <id>http://yoursite.com/2018/03/21/note3/</id>
    <published>2018-03-20T23:36:36.000Z</published>
    <updated>2018-08-08T01:44:09.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h2><h3 id="cllections"><a href="#cllections" class="headerlink" title="cllections"></a>cllections</h3><h4 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h4><p>创建自定义数据类型，具有tuple的不变性，又可以根据属性引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apple = namedtuple(&apos;Apple&apos;,[&apos;shape&apos;,&apos;taste&apos;])</span><br><span class="line">a = Apple(&apos;spherical&apos;,&apos;sweet&apos;)</span><br><span class="line">a.shape</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">&gt;&gt;&gt; q.append(&apos;x&apos;)</span><br><span class="line">&gt;&gt;&gt; q.appendleft(&apos;y&apos;)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line">deque([&apos;y&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;x&apos;])</span><br></pre></td></tr></table></figure><h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><p>使用dict时，如引用不存在的key值时，不抛出KeyError返回默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">MyDic = defaultdict(lambda:&apos;N/A&apos;)</span><br><span class="line">MyDic[&apos;key1&apos;] = 2</span><br><span class="line">MyDic[&apos;key2&apos;]</span><br></pre></td></tr></table></figure></p><h4 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h4><p>迭代字典时，按照插入顺序排列<br>odict = OrderedDict()<br>odict[‘s’]=1<br>odict[‘a’]=2<br>odict[‘e’]=3<br>list(od.key())<br>[‘s’,’a’,’e’]</p><h4 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line">c=Counter()</span><br><span class="line">for ch in &apos;programming&apos;</span><br><span class="line">    c[ch] = c[ch]+1</span><br><span class="line">c</span><br><span class="line">Counter(&#123;&apos;g&apos;: 2, &apos;m&apos;: 2, &apos;r&apos;: 2, &apos;a&apos;: 1, &apos;i&apos;: 1, &apos;o&apos;: 1, &apos;n&apos;: 1, &apos;p&apos;: 1&#125;)</span><br></pre></td></tr></table></figure><h3 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h3><p>3<em>8 = 4</em>6  2^6=64<br>base64.b64encode(b’’)#不足3的倍数用’\x00’补齐<br>base64.b64decode(b’’)#补了几个字节就在末尾加上几个’=’<br>因为URL中不出现’+’’/‘,转换为’-‘’_’<br>base64.urlsafe_b64encode(b’’)<br>base64.urlsafe_b64decode(b’’)</p><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>处理字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import struct</span><br><span class="line">&gt;&gt;&gt; struct.pack(&apos;&gt;I&apos;, 10240099)</span><br><span class="line">b&apos;\x00\x9c@c&apos;</span><br><span class="line"># &gt; 表示字节顺序是大端存储,I表示4字节无符号整数,H表示2字节无符号整数</span><br><span class="line">&gt;&gt;&gt; struct.unpack(&apos;&gt;IH&apos;, b&apos;\xf0\xf0\xf0\xf0\x80\x80&apos;)</span><br><span class="line">(4042322160, 32896)</span><br></pre></td></tr></table></figure></p><h3 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MD5,SHA1</span><br><span class="line">import hashlib</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(&apos;how to speak English?&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">print(md5.hexdigest())</span><br></pre></td></tr></table></figure><h3 id="hmac"><a href="#hmac" class="headerlink" title="hmac"></a>hmac</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import hmac</span><br><span class="line">message = b&apos;hello,world&apos;</span><br><span class="line">key = b&apos;secret&apos;</span><br><span class="line">#key,message都是bytes类型</span><br><span class="line">h = hmac.new(key,message,digestmod=&apos;MD5&apos;)</span><br><span class="line">h.hexdigest()</span><br></pre></td></tr></table></figure><h3 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line">itertools.count(1,2)#1,3,5,7...</span><br><span class="line">itertools.cycle([1,-1])#1,-1,1,-1</span><br><span class="line">itertools.repeat(&apos;a&apos;,3)</span><br><span class="line">itertools.takewhile(lambda x : x&lt;10,List)</span><br><span class="line">0 1 2 1 0</span><br><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AAABBBCCAAA&apos;):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]</span><br><span class="line">B [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</span><br><span class="line">C [&apos;C&apos;, &apos;C&apos;]</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AaaBBbcCAAa&apos;, lambda c: c.upper()):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&apos;A&apos;, &apos;a&apos;, &apos;a&apos;]</span><br><span class="line">B [&apos;B&apos;, &apos;B&apos;, &apos;b&apos;]</span><br><span class="line">C [&apos;c&apos;, &apos;C&apos;]</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;a&apos;]</span><br></pre></td></tr></table></figure><h3 id="contexttlib"><a href="#contexttlib" class="headerlink" title="contexttlib"></a>contexttlib</h3><p>一个上下文管理的对象(实现了<strong>enter</strong>(),<strong>exit</strong>(type,value,traceback)<strong>):<br>with object as var:<br>    statement<br>进入with时调用</strong>enter__()且将返回值传给var,离开后调用<strong>exit</strong>,未发生异常时的参数置为None,返回True,反之传出异常,返回False<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">class Query(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def query(self):</span><br><span class="line">        print(&apos;Query info about %s...&apos; % self.name)</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def create_query(name):</span><br><span class="line">    print(&apos;Begin&apos;)</span><br><span class="line">    q = Query(name)</span><br><span class="line">    yield q</span><br><span class="line">    print(&apos;End&apos;)</span><br></pre></td></tr></table></figure></p><p>yield的值用做__enter()<strong>返回值，执行yield之后的语句调用   \</strong>exit()__<br><strong>@closing</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import closing</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line"></span><br><span class="line">with closing(urlopen(&apos;https://www.python.org&apos;)) as page:</span><br><span class="line">    for line in page:</span><br><span class="line">        print(line)</span><br><span class="line">closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单：</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def closing(thing):</span><br><span class="line">    try:</span><br><span class="line">        yield thing</span><br><span class="line">    finally:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure></p><p><strong>urllib</strong> 浏览器请求</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用模块&quot;&gt;&lt;a href=&quot;#常用模块&quot; class=&quot;headerlink&quot; title=&quot;常用模块&quot;&gt;&lt;/a&gt;常用模块&lt;/h2&gt;&lt;h3 id=&quot;cllections&quot;&gt;&lt;a href=&quot;#cllections&quot; class=&quot;headerlink&quot; title=&quot;cllections&quot;&gt;&lt;/a&gt;cllections&lt;/h3&gt;&lt;h4 id=&quot;namedtuple&quot;&gt;&lt;a href=&quot;#namedtuple&quot; class=&quot;headerlink&quot; title=&quot;namedtuple&quot;&gt;&lt;/a&gt;namedtuple&lt;/h4&gt;&lt;p&gt;创建自定义数据类型，具有tuple的不变性，又可以根据属性引用&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Apple = namedtuple(&amp;apos;Apple&amp;apos;,[&amp;apos;shape&amp;apos;,&amp;apos;taste&amp;apos;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = Apple(&amp;apos;spherical&amp;apos;,&amp;apos;sweet&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.shape&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>note2</title>
    <link href="http://yoursite.com/2018/03/20/note2/"/>
    <id>http://yoursite.com/2018/03/20/note2/</id>
    <published>2018-03-20T00:37:07.000Z</published>
    <updated>2018-08-08T01:44:11.805Z</updated>
    
    <content type="html"><![CDATA[<p>Python靠引用来访问对象，所谓可变对象与不可变对象应该是指当前在操作的引用是指向哪里的，标签可以被任意撕下(引用的指向会变)，但是同一内存空间存放的值不会变(在内存垃圾回收机制启动之前) </p><a id="more"></a><p><em>注：在这里我理解为：放引用的内存空间里存了被引用对象的地址，放值的内存空间里放了该值的二进制码</em></p><ul><li>不可变对象：直接指向了存值的内存区域</li><li>可变对象：指向的时具有特定类型的引用</li></ul><p>浅复制：复制了当前对象中的第一层引用<br>深复制：递归赋值当前对象引用，直至找到指向直接存值的引用</p><p>3.27<br>在函数中传递切片，传的是一个浅复制对象<br>‘test(s[:])’</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python靠引用来访问对象，所谓可变对象与不可变对象应该是指当前在操作的引用是指向哪里的，标签可以被任意撕下(引用的指向会变)，但是同一内存空间存放的值不会变(在内存垃圾回收机制启动之前) &lt;/p&gt;
    
    </summary>
    
    
      <category term="pyhton" scheme="http://yoursite.com/tags/pyhton/"/>
    
  </entry>
  
  <entry>
    <title>3.19</title>
    <link href="http://yoursite.com/2018/03/19/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <id>http://yoursite.com/2018/03/19/汉诺塔/</id>
    <published>2018-03-19T02:51:31.000Z</published>
    <updated>2018-08-08T01:44:26.875Z</updated>
    
    <content type="html"><![CDATA[<p>关于递归函数问题:</p><a id="more"></a><p>def move_one(num,init,des):<br>    print(‘move ‘+str(num)+’ from ‘+init+’ to ‘+des)<br>    print(‘———————————‘)<br>def hanoi(num,init,temp,des):<br>    if num==1:<br>        move_one(num,init,des)<br>    else:<br>        hanoi(num-1,init,des,temp)<br>        move_one(num,init,des)<br>        hanoi(num-1,temp,init,des)</p><p>一件很难的事，我可以完成其中一小步，剩下的交给第二个人做。<br>第二个人接到任务时，想我可以完成其中一小步，剩下的交给第三个人做。…<br>直到任务最后被分解成简单的一小步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于递归函数问题:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java海量数据分布式存储</title>
    <link href="http://yoursite.com/2018/03/18/Java%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2018/03/18/Java海量数据分布式存储/</id>
    <published>2018-03-18T14:06:31.000Z</published>
    <updated>2018-08-08T01:44:28.890Z</updated>
    
    <content type="html"><![CDATA[<p>前备知识：<br>javaWeb，部署tomcat<br>HTTP协议：</p><ul><li>请求行，请求头，请求体</li></ul><p>[toc]</p><h3 id="JAVA海量数据分布式开发"><a href="#JAVA海量数据分布式开发" class="headerlink" title="JAVA海量数据分布式开发"></a>JAVA海量数据分布式开发</h3><p>severlet:<br>response.getWriter().Writer(“”)<br>response.setContentType(“text/html;charset= utf-8”)</p><a id="more"></a><p>解决HTML在servlet中拼接问题：客户端请求servlet，servlet转发给jsp，jsp响应<br>or 重定向<br>package : controller, dao<br>com.baidu.controller com.baidu.service com.baidu.dao com.baidu.bean</p><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><table><thead><tr><th>controller 控制层</th><th>service服务器</th><th>dao 持久层</th></tr></thead><tbody><tr><td>servlet class：Reqisteservlet</td><td>userservice 业务逻辑</td><td>数据库处理</td></tr><tr><td>new User(): <strong>userBean</strong></td><td>接收userBean并处理</td></tr></tbody></table><blockquote><p>userBean : 封装对象属性的类(save user’s information)有时也建立model类，上诉三层中的数据由他打包传递</p></blockquote><h4 id="coockie"><a href="#coockie" class="headerlink" title="coockie"></a>coockie</h4><table><thead><tr><th>coockie</th><th>session</th></tr></thead><tbody><tr><td>contain: session id，在客户端</td><td>保存在服务器端</td></tr><tr><td>默认关闭浏览器后coockie消失，可设置coockie有效时间</td></tr></tbody></table><h4 id="filter-过滤器"><a href="#filter-过滤器" class="headerlink" title="filter:过滤器"></a>filter:过滤器</h4><p>MVC : model view controller</p><p><strong><em>Homework</em></strong><br>servlet jdbc</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前备知识：&lt;br&gt;javaWeb，部署tomcat&lt;br&gt;HTTP协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求行，请求头，请求体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;JAVA海量数据分布式开发&quot;&gt;&lt;a href=&quot;#JAVA海量数据分布式开发&quot; class=&quot;headerlink&quot; title=&quot;JAVA海量数据分布式开发&quot;&gt;&lt;/a&gt;JAVA海量数据分布式开发&lt;/h3&gt;&lt;p&gt;severlet:&lt;br&gt;response.getWriter().Writer(“”)&lt;br&gt;response.setContentType(“text/html;charset= utf-8”)&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>python_note</title>
    <link href="http://yoursite.com/2018/03/06/python-note/"/>
    <id>http://yoursite.com/2018/03/06/python-note/</id>
    <published>2018-03-06T12:36:31.000Z</published>
    <updated>2018-08-08T01:44:20.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python复习"><a href="#Python复习" class="headerlink" title="Python复习"></a>Python复习</h3><p>@(Python小结)[摘自廖雪峰博客]</p><p>[TOC]</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="编码方式：uincode"><a href="#编码方式：uincode" class="headerlink" title="编码方式：uincode"></a>编码方式：uincode</h5><p>print 字符串，每遇到 ‘ , ‘自动换成空格</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&apos;文&apos;</span><br></pre></td></tr></table></figure><h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure><h5 id="补0和指定小数点"><a href="#补0和指定小数点" class="headerlink" title="补0和指定小数点"></a>补0和指定小数点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;%2d-%02d&apos; % (3, 1))  3-01</span><br><span class="line">print(&apos;%3d-%03d&apos; % (3, 1))  3-001</span><br><span class="line">print(&apos;%.2f&apos; % 3.1415926)   3.14</span><br></pre></td></tr></table></figure><h5 id="list-amp-tuple"><a href="#list-amp-tuple" class="headerlink" title="list&amp;tuple"></a>list&amp;tuple</h5><p>list:   append(var)    insert(index,var)      pop(i)    list[-1]:the last one<br>tuple:  指向不可变</p><h5 id="dict-amp-set"><a href="#dict-amp-set" class="headerlink" title="dict&amp;set"></a>dict&amp;set</h5><p>dict：查找迅速，查找时间不会随key的增加而增加，存储位置根据key采用哈希算法，因此key不可改变（注意不是不可重复）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">d.get(key)</span><br></pre></td></tr></table></figure></p><p>set：类似dict，只存key，无value。可做类似集合的交合并,输入的元素不可变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">s1.remove(1)</span><br></pre></td></tr></table></figure></p><p>return : reture多值时实际上是return tuple</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="默认参数：-必须指向不变对象"><a href="#默认参数：-必须指向不变对象" class="headerlink" title="默认参数： 必须指向不变对象"></a>默认参数： 必须指向不变对象</h5><h5 id="可变参数：-args"><a href="#可变参数：-args" class="headerlink" title="可变参数：*args"></a>可变参数：*args</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers)</span><br><span class="line">&gt;&gt;&gt;nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt;calc(1,2,3)</span><br><span class="line">&gt;&gt;&gt;&gt;calc()</span><br><span class="line">&gt;&gt;&gt;calc(*nums)</span><br></pre></td></tr></table></figure><h5 id="关键字参数：-kw接收dict-允许传入0个或多个含参数名的参数"><a href="#关键字参数：-kw接收dict-允许传入0个或多个含参数名的参数" class="headerlink" title="关键字参数：**kw接收dict  允许传入0个或多个含参数名的参数"></a>关键字参数：**kw接收dict  允许传入0个或多个含参数名的参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure><h5 id="命名关键字参数：需要分隔符-后面视为命名关键字参数"><a href="#命名关键字参数：需要分隔符-后面视为命名关键字参数" class="headerlink" title="命名关键字参数：需要分隔符      后面视为命名关键字参数"></a>命名关键字参数：需要分隔符 <em>     </em>后面视为命名关键字参数</h5><p><code>def person(name, age, *, city, job)</code></p><h5 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def f1(a, b, c=0, *args, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c=0, *, d, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c=3)</span><br><span class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</span><br><span class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</span><br></pre></td></tr></table></figure><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kkk&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; args = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f2(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>前10个数，每两个取一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10:2]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>所有数，每5个取一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[::5]</span><br><span class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</span><br></pre></td></tr></table></figure></p><p>甚至什么都不写，只写[:]就可以原样复制一个list：</p><p><code>L[:][0, 1, 2, 3, ..., 99]</code><br>(问题横出！正常文本+代码块，多次重复此格式后出现各种异常, 是因为单行代码用了代码块符号)<br>迭代<br>enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br><span class="line">for x, y in [(1, 1), (2, 4), (3, 9)]:</span><br><span class="line">...     print(x, y)</span><br><span class="line">...</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure></p><p>切分字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.split(r&apos;[\s\,\;]+&apos;, &apos;a,b;; c  d&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure></p><p>分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; m = re.match(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;re.Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; m.group()</span><br><span class="line">&apos;010-12345&apos;</span><br><span class="line">&gt;&gt;&gt; m.groups()</span><br><span class="line">(&apos;010&apos;, &apos;12345&apos;)</span><br><span class="line">&gt;&gt;&gt; m.group(1)</span><br><span class="line">&apos;010&apos;</span><br></pre></td></tr></table></figure></p><p>?阻止正则表达式的贪婪匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;102300&apos;, &apos;&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;1023&apos;, &apos;00&apos;)</span><br></pre></td></tr></table></figure></p><p>生成自己的正则表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line"># 编译:</span><br><span class="line">&gt;&gt;&gt; re_telephone = re.compile(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;)</span><br><span class="line"># 使用：</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-12345&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;12345&apos;)</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-8086&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;8086&apos;)</span><br></pre></td></tr></table></figure></p><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure><p>dic 的 items()可以同时迭代key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class="line">[k + &apos;=&apos; + v for k, v in d.items()]</span><br><span class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</span><br></pre></td></tr></table></figure></p><h5 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器 generator"></a>生成器 generator</h5><p>函数定义中包含：yield关键字，每次调用next()执行后，遇到yield就返回<br>将列表生成式的 [] 换为 ()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure></p><p> Python 眼中的for循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> # 首先获得Iterator对象(将Iterable对象转换为Iterator):</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"> #循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></p><p>####函数</p><h5 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h5><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h5><h5 id="fillter-过滤序列"><a href="#fillter-过滤序列" class="headerlink" title="fillter(): 过滤序列"></a>fillter(): 过滤序列</h5><p>filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list<br><code>fillter(f,list)</code><br>f 为函数，返回true or false</p><h5 id="sorted-可接受函数作为参数，由key指定函数"><a href="#sorted-可接受函数作为参数，由key指定函数" class="headerlink" title="sorted()  可接受函数作为参数，由key指定函数"></a>sorted()  可接受函数作为参数，由key指定函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)</span><br><span class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</span><br></pre></td></tr></table></figure><h5 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数  lambda"></a>匿名函数  lambda</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lambda x : x*x   #等同于 </span><br><span class="line">def f(x)</span><br><span class="line">    return x*x</span><br></pre></td></tr></table></figure><h5 id="返回函数-参数和变量都保存在返回的函数中——闭包"><a href="#返回函数-参数和变量都保存在返回的函数中——闭包" class="headerlink" title="返回函数  参数和变量都保存在返回的函数中——闭包"></a>返回函数  参数和变量都保存在返回的函数中——闭包</h5><p>因为不是要计算值，只是要按需求值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br><span class="line">#每次调用都返回新函数</span><br><span class="line">&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f1==f2</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p><p><strong><em>返回函数引用局部变量时：不要引用循环变量，或后续发生变化的变量</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><p><strong>nonlocal</strong> 函数使用外层函数变量（局部变量）</p><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>增强函数功能，又不改变函数定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br><span class="line">#等价于 now = log(now) 所以装饰器传参要定义三层</span><br><span class="line">&gt;&gt;&gt; now()</span><br><span class="line">call now():</span><br><span class="line">2015-3-25</span><br></pre></td></tr></table></figure></p><p>可传参装饰器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        #now.__name__ = &apos;wrapper&apos;，所以需要用下列函数改变now的名字，防止依赖函数名的代码出错</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br></pre></td></tr></table></figure></p><h5 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h5><p>在原函数的基础上固定传入参数，创建新函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> import functools</span><br><span class="line">&gt;&gt;&gt; int2 = functools.partial(int, base=2)</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</span><br><span class="line">64</span><br></pre></td></tr></table></figure></p><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&apos; a test module &apos;</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Michael Liao&apos;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    if len(args)==1:</span><br><span class="line">        print(&apos;Hello, world!&apos;)</span><br><span class="line">    elif len(args)==2:</span><br><span class="line">        print(&apos;Hello, %s!&apos; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Too many arguments!&apos;)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>第1行：使文件可以直接在Unix/Linux/Max上运行<br>第4行：文档注释，任何模块的第一行字符串都视为文档注释<br>第6行：加上作者<br>(不知道和setup.py里的注释有啥区别)<br><strong>name</strong>置为<strong>main</strong>：通过命令行执行额外代码，可用于测试</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>创建类实例：<br><code>a = Account(“he”,1000) #调用 Account.__init__(“he”,1000)</code><br>作用域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">calss Animal(object):</span><br><span class="line">    def __init__(self,age):</span><br><span class="line">        self.age = age</span><br><span class="line">    def jump(self):</span><br><span class="line">        print(&quot;jump!&quot;)</span><br><span class="line">    def shut(self):</span><br><span class="line">        jump(self)    #error,类中没有作用域</span><br><span class="line">        self.jump()   #这样才能指向创建的实例</span><br></pre></td></tr></table></figure></p><p>继承：<br>class Dog(Animal):<br>    def <strong>init</strong>(self,age,name):    #<br>        Animal.<strong>init</strong>(self,age)   #初始化基类<br>        self.name = name<br>    def shut:<br>        print(“wang!”)</p><p>super():<br>    super.function()    #调用父类的方法，在继承的父类的方法中无新的实现</p><p>多继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A(object): pass</span><br><span class="line">class B(A): pass</span><br><span class="line">class C(A,B): pass</span><br></pre></td></tr></table></figure></p><p>严重的程序设计错误，基类列表中先搜索了A，但显然B比A特殊</p><p>鸭子类型：<br>Python对象的特征由对象的方法决定，而非父类，对于实现了同样方法，接口的对象，可以看作是相似类。例如，当一个方法需要传入一个类对象时，可以传入与该类相似的类对象，并不限定于该类的对象及子类。<br>实例可以绑定任意数据：a，b均继承A，a.extend = 2，但b并没有extend属性<br><strong>数据封装</strong>：在变量前面添加 __或者单下划线，双下划线的变量会被Python解释器改名，但这里确实没有什么机制限制你对私有变量的访问<br><strong>多态</strong>：鸭子类型<br><strong>isinstance</strong>：类型判断，可以判断是否是多类型中的一种  ([1, 2, 3], (list, tuple))<br><strong>实例属性&amp;类属性</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name = &apos;Student&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure></p><h5 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h5><p>限制实例能添加的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</span><br><span class="line">&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;</span><br><span class="line">&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos;</span><br></pre></td></tr></table></figure></p><h5 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h5><p>将类方法定义为属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value   </span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br></pre></td></tr></table></figure></p><h5 id="多重继承-MixIn"><a href="#多重继承-MixIn" class="headerlink" title="多重继承  MixIn"></a>多重继承  MixIn</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Mammal, Runnable):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h5 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h5><p>实现一些特定的方法使对象成为特定的类（鸭子类型思想）<br><strong><strong>getattr</strong></strong>：可以将类的属性和方法动态处理，这里有一个关于REST API的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Chain(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, path=&apos;&apos;):</span><br><span class="line">        self._path = path</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, path):</span><br><span class="line">        return Chain(&apos;%s/%s&apos; % (self._path, path))</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self._path</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; Chain().status.user.timeline.list</span><br><span class="line">&apos;/status/user/timeline/list&apos;</span><br></pre></td></tr></table></figure></p><p><strong><strong>call</strong></strong>：通过实例直接调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&apos;My name is %s.&apos; % self.name)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s = Student(&apos;Michael&apos;)</span><br><span class="line">&gt;&gt;&gt; s() # self参数不要传入</span><br><span class="line">My name is Michael.</span><br><span class="line">#判断一个对象是否能被调用</span><br><span class="line">&gt;&gt;&gt; callable(Student())</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><h5 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h5><p>每个对象都是类的唯一实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br></pre></td></tr></table></figure></p><h5 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h5><p><strong>metaclass</strong>：控制类的创建行为<br>ORM框架：使用者根据表结构定义出对应的类来（因此需要控制类的创建方式）<br>抽象出一层类的模板</p><h4 id="错误，调试，测试"><a href="#错误，调试，测试" class="headerlink" title="错误，调试，测试"></a>错误，调试，测试</h4><p><strong>try…except…finally</strong><br><strong>raise</strong>：抛出错误</p><p><strong>assert</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    assert n != 0, &apos;n is zero!&apos;</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    foo(&apos;0&apos;)</span><br><span class="line">    </span><br><span class="line">$ python err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">AssertionError: n is zero!</span><br><span class="line"></span><br><span class="line">$ python -O err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p><p><strong>logging</strong><br>允许指定信息级别，有debug，info，warning，error；level = INFO时，logging.debug失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br></pre></td></tr></table></figure></p><p><strong>pdb</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python -m pdb err.py</span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()</span><br><span class="line">-&gt; s = &apos;0&apos;</span><br><span class="line">(Pdb) l</span><br><span class="line">  1     # err.py</span><br><span class="line">  2  -&gt; s = &apos;0&apos;</span><br><span class="line">  3     n = int(s)</span><br><span class="line">  4     print(10 / n)</span><br></pre></td></tr></table></figure></p><p>输入命令n可以单步执行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) n</span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()</span><br><span class="line">-&gt; n = int(s)</span><br><span class="line">(Pdb) n</span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()</span><br><span class="line">-&gt; print(10 / n)</span><br></pre></td></tr></table></figure></p><p>任何时候都可以输入命令p 变量名来查看变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) p s</span><br><span class="line">&apos;0&apos;</span><br><span class="line">(Pdb) p n</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>输入命令q结束调试，退出程序：<br><code>(Pdb) q</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># err.py</span><br><span class="line">import pdb</span><br><span class="line"></span><br><span class="line">s = &apos;0&apos;</span><br><span class="line">n = int(s)</span><br><span class="line">pdb.set_trace() # 运行到这里会自动暂停</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure></p><p>运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python err.py </span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()</span><br><span class="line">-&gt; print(10 / n)</span><br><span class="line">(Pdb) p n</span><br><span class="line">0</span><br><span class="line">(Pdb) c</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    print(10 / n)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p><h4 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h4><h5 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h5><p>for line in f.readlines():<br>    print(line.strip())<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(size)</span><br><span class="line">readlines()：适用配置文件，按行返回list</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#读二进制文件&apos;rb&apos;</span><br><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;,encoding=&apos;gbk&apos;,errors=&apos;ignore&apos;) as f:</span><br><span class="line">    print(f.read())</span><br><span class="line">#写文件</span><br><span class="line">#&apos;w&apos;：直接覆盖模式，&apos;a&apos;：追加模式</span><br><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure><h5 id="内存读写"><a href="#内存读写" class="headerlink" title="内存读写"></a>内存读写</h5><p>在内存中操作str和bytes，提供一个和读取文件一样的接口<br>StringIO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     s = f.readline()</span><br><span class="line">...     if s == &apos;&apos;:</span><br><span class="line">...         break</span><br><span class="line">...     print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure></p><p>BytesIO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br></pre></td></tr></table></figure></p><h5 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ.get(&apos;PATH&apos;)</span><br><span class="line">&apos;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&apos;</span><br><span class="line">&gt;&gt;&gt; os.environ.get(&apos;x&apos;, &apos;default&apos;)</span><br><span class="line">&apos;default&apos;</span><br><span class="line"></span><br><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)</span><br><span class="line">&apos;/Users/michael/testdir&apos;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)</span><br><span class="line">(&apos;/Users/michael/testdir&apos;, &apos;file.txt&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#直接让你得到文件扩展名，很多时候非常方便：</span><br><span class="line">&gt;&gt;&gt; os.path.splitext(&apos;/path/to/file.txt&apos;)</span><br><span class="line">(&apos;/path/to/file&apos;, &apos;.txt&apos;)</span><br><span class="line"></span><br><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br><span class="line"></span><br><span class="line">#列出当前目录下的所有目录，只需要一行代码：</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)]</span><br><span class="line">[&apos;.lein&apos;, &apos;.local&apos;, &apos;.m2&apos;, &apos;.npm&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;.vim&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, ...]</span><br><span class="line"></span><br><span class="line">#要列出所有的.py文件，也只需一行代码：</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]</span><br><span class="line">[&apos;apis.py&apos;, &apos;config.py&apos;, &apos;models.py&apos;, &apos;pymonitor.py&apos;, &apos;test_db.py&apos;, &apos;urls.py&apos;, &apos;wsgiapp.py&apos;]</span><br></pre></td></tr></table></figure><h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b&apos;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">#反序列化</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; d = pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; json.dumps(d)</span><br><span class="line">&apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">#反序列化</span><br><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; json.loads(json_str)</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure><p>class转换为JSON<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#在类中定义一个将对象转为dict的函数</span><br><span class="line">def student2dict(std):</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;name&apos;: std.name,</span><br><span class="line">        &apos;age&apos;: std.age,</span><br><span class="line">        &apos;score&apos;: std.score</span><br><span class="line">    &#125;</span><br><span class="line">#default关键字指定转换函数</span><br><span class="line">&gt;&gt;&gt; print(json.dumps(s, default=student2dict))</span><br><span class="line">&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88&#125;</span><br><span class="line"></span><br><span class="line">#反序列化</span><br><span class="line">def dict2student(d):</span><br><span class="line">    return Student(d[&apos;name&apos;], d[&apos;age&apos;], d[&apos;score&apos;])</span><br><span class="line">运行结果如下：</span><br><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student object at 0x10cd3c190&gt;</span><br></pre></td></tr></table></figure></p><p>常用的函数：<br>range(n) 生成0~n-1的序列<br>bool():return true or false<br>abs()  int()  float()  str()<br>isinstance(a,str) : 判断a是否是str类型<br>itemgetter函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3] </span><br><span class="line">&gt;&gt;&gt; b=operator.itemgetter(1)      //定义函数b，获取对象的第1个域的值</span><br><span class="line">&gt;&gt;&gt; b(a)</span><br></pre></td></tr></table></figure></p><p><strong>ThreadLocal</strong>：为线程绑定自己的全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建全局ThreadLocal对象:</span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line">def process_student():</span><br><span class="line">    # 获取当前线程关联的student:</span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">def process_thread(name):</span><br><span class="line">    # 绑定ThreadLocal的student:</span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(&apos;Alice&apos;,), name=&apos;Thread-A&apos;)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">#执行结果：</span><br><span class="line">Hello, Alice (in Thread-A)</span><br><span class="line">Hello, Bob (in Thread-B)</span><br></pre></td></tr></table></figure></p><p>####正则表达式<br>规则</p><ul><li><p>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线；</p></li><li><p>[0-9a-zA-Z_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等；</p></li><li><p>[a-zA-Z_][0-9a-zA-Z_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</p></li><li><p>[a-zA-Z_][0-9a-zA-Z_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p></li><li><p>A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。</p></li><li><p>^表示行的开头，^\d表示必须以数字开头。</p></li><li><p>\$表示行的结束，\d\$表示必须以数字结束。</p></li></ul><p>re模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&apos;, &apos;010 12345&apos;)</span><br><span class="line">test = &apos;用户输入的字符串&apos;</span><br><span class="line">if re.match(r&apos;正则表达式&apos;, test):</span><br><span class="line">    print(&apos;ok&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;failed&apos;)</span><br></pre></td></tr></table></figure></p><h4 id="的使用"><a href="#的使用" class="headerlink" title="_ 的使用"></a>_ 的使用</h4><p>1.代表上一行执行的结果<br>2.分配一个特定名称(I don’t care the value of _)<br><figure class="highlight plain"><figcaption><span>_ in range(20):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_something()</span><br></pre></td></tr></table></figure></p><p>3.实现国际化和本地化字符串之间翻译查找的函数名称<br><figure class="highlight plain"><figcaption><span>django.utils.translation import ugettext as _ </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse </span><br><span class="line">def my_view(request): </span><br><span class="line">    output = _(&quot;Welcome to my site.&quot;) </span><br><span class="line">    return HttpResponse(output)</span><br></pre></td></tr></table></figure></p><p><strong>名称前的单下划线*</strong><br>_myself : 被声明为私有变量，import时就不会引入该种变量，除非该变量在 <strong>all</strong>中显示出现<br><strong>名称前的双下划线*</strong><br>子类继承该方法后，并不能覆盖父类的方法，而是生成一个新方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A(object): </span><br><span class="line">... def _internal_use(self): </span><br><span class="line">... pass </span><br><span class="line">... def __method_name(self): </span><br><span class="line">... pass </span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; dir(A()) </span><br><span class="line">[&apos;_A__method_name&apos;, ..., &apos;_internal_use&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class B(A): </span><br><span class="line">... def __method_name(self): </span><br><span class="line">... pass </span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; dir(B()) </span><br><span class="line">[&apos;_A__method_name&apos;, &apos;_B__method_name&apos;, ..., &apos;_internal_use&apos;]</span><br></pre></td></tr></table></figure></p><p><strong>名称前后的双下划线（如：<strong>init</strong>）</strong><br>特殊方法名，如默认的构造函数</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Python复习&quot;&gt;&lt;a href=&quot;#Python复习&quot; class=&quot;headerlink&quot; title=&quot;Python复习&quot;&gt;&lt;/a&gt;Python复习&lt;/h3&gt;&lt;p&gt;@(Python小结)[摘自廖雪峰博客]&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h4&gt;&lt;h5 id=&quot;编码方式：uincode&quot;&gt;&lt;a href=&quot;#编码方式：uincode&quot; class=&quot;headerlink&quot; title=&quot;编码方式：uincode&quot;&gt;&lt;/a&gt;编码方式：uincode&lt;/h5&gt;&lt;p&gt;print 字符串，每遇到 ‘ , ‘自动换成空格&lt;/p&gt;
    
    </summary>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>网络问题</title>
    <link href="http://yoursite.com/2017/12/08/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/12/08/网络问题/</id>
    <published>2017-12-08T13:26:50.000Z</published>
    <updated>2018-08-08T01:58:54.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-29-网页无法打开"><a href="#1-29-网页无法打开" class="headerlink" title="1.29 网页无法打开"></a>1.29 网页无法打开</h3><p>在这里就不得不吐槽一下了，从一月初发现自己笔记本域名解析出现问题，具体表现为：网页无法打开，但是qq等应用程序可以正常使用；怀疑是本地域名服务器出现了问题，按这个思路找了很多解决办法未果。之后又发现连接校园网的时候出现这个问题，但是连接手机热点却能正常访问网页，于是怀疑是校园网的原因。尝试多种解决办法无果后，借着自己手机流量多(就是懒)，便把问题搁置了。1.19回家之后就开始练车，到今天再次用电脑时，发现连家里的WiFi还是有同样问题。最后，这条命令：</p><a id="more"></a><p><strong>netsh winsock reset</strong><br>解决了这个磨人的问题。说是windows网络编程的接口是winsock,可能是安装软件的时候winsock的目录被修改，导致网络配置出错。即winsock与网络连接传输信息时参数被修改，导致无法发出正确请求无法获得正确响应。<br>综上：<br>问题：<br>1.笔记本无法打开网页，例如qq等的应用可以正常使用<br>2.该问题出现在笔记本链接WiFi时，当笔记本连接手机热点时问题消失<br>解决办法：<br>netsh winsock reset<br>我的看法：winsock是应用层协议，连接手机热点发出的包协议头部与连接wifi发出的包不同，当其目录被修改时导致接包方解析出错。</p><h4 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h4><p>续问题，电脑再次连接校园网出现问题。网页无法打开，qq正常运行。网络诊断dns服务器未检测到。当前域名服务器为8.8.8.8，Google可正常搜索，搜索到的内容也无法打开</p><h4 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h4><p>只支持有线网络上网</p><h4 id="3-15"><a href="#3-15" class="headerlink" title="3.15"></a>3.15</h4><p>学校限制外部DNS(之前因为域名服务器有问题，自己手动改过DNS)，导致无法连接上网。改为DNS服务器自动获取后，成功连上DLUT！！！这两天一直呆实验室或者机房，靠网线上网。。。<br>解决方法：因为实验室搭网线，来了一个小哥，他帮我瞬间能弄好的，简直无敌感谢他！<br>我的诟病：<br>    1.想法里有过正确的解决方式，但是因为暂时不可达性导致错过<br>    2.有问题不及时解决，不到非不得已就一直拖着<br>    3.缺少和别人的交流，模糊了互相帮助和有偿服务的界限<br>    4.对自己和别人的评价不能恰如其分<br>总之，大部分人的价值是在被别的人需要中体现的，所以乐于去帮助别人，也学会适当的寻求别人的帮助，不是一个人单枪匹马就叫英雄，你在群体中成长会更迅速。还有，排除了一切不可能，那么唯一剩下的这个可能性就是结果。不要再在事实面前自我迷惑了。</p><p>一旦出现错误，就开始怀疑自己所有工作，导致无法定位问题的源头</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-29-网页无法打开&quot;&gt;&lt;a href=&quot;#1-29-网页无法打开&quot; class=&quot;headerlink&quot; title=&quot;1.29 网页无法打开&quot;&gt;&lt;/a&gt;1.29 网页无法打开&lt;/h3&gt;&lt;p&gt;在这里就不得不吐槽一下了，从一月初发现自己笔记本域名解析出现问题，具体表现为：网页无法打开，但是qq等应用程序可以正常使用；怀疑是本地域名服务器出现了问题，按这个思路找了很多解决办法未果。之后又发现连接校园网的时候出现这个问题，但是连接手机热点却能正常访问网页，于是怀疑是校园网的原因。尝试多种解决办法无果后，借着自己手机流量多(就是懒)，便把问题搁置了。1.19回家之后就开始练车，到今天再次用电脑时，发现连家里的WiFi还是有同样问题。最后，这条命令：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
