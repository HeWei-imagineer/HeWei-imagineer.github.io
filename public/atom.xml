<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeWei</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-18T14:08:57.478Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>HeWei-imagineer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java海量数据分布式存储</title>
    <link href="http://yoursite.com/2018/03/18/Java%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2018/03/18/Java海量数据分布式存储/</id>
    <published>2018-03-18T14:06:31.000Z</published>
    <updated>2018-03-18T14:08:57.478Z</updated>
    
    <content type="html"><![CDATA[<p>前备知识：<br>javaWeb，部署tomcat<br>HTTP协议：</p><ul><li>请求行，请求头，请求体</li></ul><p>[toc]</p><p>###JAVA海量数据分布式开发<br>severlet:<br>response.getWriter().Writer(“”)<br>response.setContentType(“text/html;charset= utf-8”)<br>解决HTML在servlet中拼接问题：客户端请求servlet，servlet转发给jsp，jsp响应<br>or 重定向<br>package : controller, dao<br>com.baidu.controller com.baidu.service com.baidu.dao com.baidu.bean</p><h4 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h4><table><thead><tr><th>controller 控制层</th><th>service服务器</th><th>dao 持久层</th></tr></thead><tbody><tr><td>servlet class：Reqisteservlet</td><td>userservice 业务逻辑</td><td>数据库处理</td></tr><tr><td>new User(): <strong>userBean</strong></td><td>接收userBean并处理</td></tr></tbody></table><blockquote><p>userBean : 封装对象属性的类(save user’s information)有时也建立model类，上诉三层中的数据由他打包传递</p></blockquote><p>####coockie<br>|coockie|session<br>|————-|<br>|contain: session id，在客户端|保存在服务器端<br>|默认关闭浏览器后coockie消失，可设置coockie有效时间</p><p>####filter:过滤器</p><p>MVC : model view controller</p><p><strong><em>Homework</em></strong><br>servlet jdbc</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前备知识：&lt;br&gt;javaWeb，部署tomcat&lt;br&gt;HTTP协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求行，请求头，请求体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;###JAVA海量数据分布式开发&lt;br&gt;severlet:&lt;br&gt;response.getWri
      
    
    </summary>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>interview</title>
    <link href="http://yoursite.com/2018/03/18/interview/"/>
    <id>http://yoursite.com/2018/03/18/interview/</id>
    <published>2018-03-18T09:19:03.000Z</published>
    <updated>2018-03-18T14:00:21.389Z</updated>
    
    <content type="html"><![CDATA[<p><strong>阿里一面</strong><br>投了数据研发岗，开始是简单的自我介绍，然后第一部分问了我对数据的理解。随后谈了自己对数据仓库的认识，面试官貌似对我这点的回答还算满意。第二部分谈了在线编程题，我自己的算法和题目耦合太过紧密，讲的时候思路也不是很清晰。在线测试的时候只是用排列组合算了一下，没来得及用代码实现，随后放在Github上吧。第三部分谈了项目，问得也比较具体，不是那种知识点的提问而是根据你的兴趣逐步提问的。因为谈到Java内存回收，就问了我一下Java如何管理内存的，还问了一下Java虚拟机。<br>这是我的第一个面试，有点小激动，也坚定了自己要和一群充满极客精神的人共事的想法。答的差强人意，所以还有很多要做的事。Fighting！</p><p><strong>腾讯一面</strong><br>我记得自己也是投了数据相关的岗位的，但是自我介绍完之后，面试官就开始问我各种操作系统，计算机网络的问题，数据结构只问了一个各种排序及复杂度。<br>1.TCP是如何保证数据可靠传输<br>2.对线程，进程的理解,线程间通信<br>3.c++如何知道内存泄漏<br>4.socket通信<br>5.Linux命令，如何查看进程运行状态等<br>然后是自己做的项目<br>最后我问了面试官他们招实习生是去干嘛的，然后他说是做后端，为相应程序提供可视化界面，好像要去规范数据，调参什么的。估计我是投错岗了，但是也提醒了自己，要是还没有点擅长的方面，就只能去搬砖了，重要的是到时候怕是连搬砖都搬不好。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;阿里一面&lt;/strong&gt;&lt;br&gt;投了数据研发岗，开始是简单的自我介绍，然后第一部分问了我对数据的理解。随后谈了自己对数据仓库的认识，面试官貌似对我这点的回答还算满意。第二部分谈了在线编程题，我自己的算法和题目耦合太过紧密，讲的时候思路也不是很清晰。在线测试
      
    
    </summary>
    
    
      <category term="thoughts" scheme="http://yoursite.com/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>python_note</title>
    <link href="http://yoursite.com/2018/03/06/python-note/"/>
    <id>http://yoursite.com/2018/03/06/python-note/</id>
    <published>2018-03-06T12:36:31.000Z</published>
    <updated>2018-03-18T13:57:30.016Z</updated>
    
    <content type="html"><![CDATA[<p>###Python复习<br>@(Python小结)[摘自廖雪峰博客]</p><p>[TOC]</p><p>####基础</p><p>#####编码方式：uincode<br>print 字符串，每遇到 ‘ , ‘自动换成空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&apos;文&apos;</span><br></pre></td></tr></table></figure></p><p>#####格式化字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure></p><p>#####补0和指定小数点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;%2d-%02d&apos; % (3, 1))  3-01</span><br><span class="line">print(&apos;%3d-%03d&apos; % (3, 1))  3-001</span><br><span class="line">print(&apos;%.2f&apos; % 3.1415926)   3.14</span><br></pre></td></tr></table></figure></p><p>#####list&amp;tuple<br>list:   append(var)    insert(index,var)      pop(i)    list[-1]:the last one<br>tuple:  指向不可变</p><p>#####dict&amp;set<br>dict：查找迅速，查找时间不会随key的增加而增加，存储位置根据key采用哈希算法，因此key不可改变（注意不是不可重复）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">d.get(key)</span><br></pre></td></tr></table></figure></p><p>set：类似dict，只存key，无value。可做类似集合的交合并,输入的元素不可变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">s1.remove(1)</span><br></pre></td></tr></table></figure></p><p>return : reture多值时实际上是return tuple</p><p>####函数</p><p>#####默认参数： 必须指向不变对象</p><p>#####可变参数：*args<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers)</span><br><span class="line">&gt;&gt;&gt;nums = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt;calc(1,2,3)</span><br><span class="line">&gt;&gt;&gt;&gt;calc()</span><br><span class="line">&gt;&gt;&gt;calc(*nums)</span><br></pre></td></tr></table></figure></p><p>#####关键字参数：**kw接收dict  允许传入0个或多个含参数名的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name:&apos;, name, &apos;age:&apos;, age, &apos;other:&apos;, kw)</span><br><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>#####命名关键字参数：需要分隔符 <em>     </em>后面视为命名关键字参数<br><code>def person(name, age, *, city, job)</code></p><p>#####参数组合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def f1(a, b, c=0, *args, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c=0, *, d, **kw):</span><br><span class="line">    print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">a = 1 b = 2 c = 0 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c=3)</span><br><span class="line">a = 1 b = 2 c = 3 args = () kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)</span><br><span class="line">a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d=99, ext=None)</span><br><span class="line">a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125;</span><br></pre></td></tr></table></figure></p><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kkk&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; args = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f2(*args, **kw)</span><br><span class="line">a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>####高级特性</p><p>#####切片<br>前10个数，每两个取一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10:2]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>所有数，每5个取一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[::5]</span><br><span class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</span><br></pre></td></tr></table></figure></p><p>甚至什么都不写，只写[:]就可以原样复制一个list：</p><p><code>L[:][0, 1, 2, 3, ..., 99]</code><br>(问题横出！正常文本+代码块，多次重复此格式后出现各种异常, 是因为单行代码用了代码块符号)<br>迭代<br>enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br><span class="line">for x, y in [(1, 1), (2, 4), (3, 9)]:</span><br><span class="line">...     print(x, y)</span><br><span class="line">...</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure></p><p>切分字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.split(r&apos;[\s\,\;]+&apos;, &apos;a,b;; c  d&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure></p><p>分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; m = re.match(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;re.Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; m.group()</span><br><span class="line">&apos;010-12345&apos;</span><br><span class="line">&gt;&gt;&gt; m.groups()</span><br><span class="line">(&apos;010&apos;, &apos;12345&apos;)</span><br><span class="line">&gt;&gt;&gt; m.group(1)</span><br><span class="line">&apos;010&apos;</span><br></pre></td></tr></table></figure></p><p>?阻止正则表达式的贪婪匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;102300&apos;, &apos;&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;1023&apos;, &apos;00&apos;)</span><br></pre></td></tr></table></figure></p><p>生成自己的正则表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line"># 编译:</span><br><span class="line">&gt;&gt;&gt; re_telephone = re.compile(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;)</span><br><span class="line"># 使用：</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-12345&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;12345&apos;)</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-8086&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;8086&apos;)</span><br></pre></td></tr></table></figure></p><p>#####列表生成式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure></p><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]</span><br><span class="line">[&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;]</span><br></pre></td></tr></table></figure><p>dic 的 items()可以同时迭代key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class="line">[k + &apos;=&apos; + v for k, v in d.items()]</span><br><span class="line">[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=C&apos;]</span><br></pre></td></tr></table></figure></p><p>#####生成器 generator<br>函数定义中包含：yield关键字，每次调用next()执行后，遇到yield就返回<br>将列表生成式的 [] 换为 ()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g = (x * x for x in range(10))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;</span><br></pre></td></tr></table></figure></p><p> Python 眼中的for循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> # 首先获得Iterator对象(将Iterable对象转换为Iterator):</span><br><span class="line">it = iter([1, 2, 3, 4, 5])</span><br><span class="line"> #循环:</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        # 获得下一个值:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        # 遇到StopIteration就退出循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure></p><p>####函数</p><p>#####map()</p><p>#####reduce()</p><p>#####fillter(): 过滤序列<br>filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list<br><code>fillter(f,list)</code><br>f 为函数，返回true or false</p><p>#####sorted()  可接受函数作为参数，由key指定函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)</span><br><span class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</span><br></pre></td></tr></table></figure></p><p>#####匿名函数  lambda<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lambda x : x*x   #等同于 </span><br><span class="line">def f(x)</span><br><span class="line">    return x*x</span><br></pre></td></tr></table></figure></p><p>#####返回函数  参数和变量都保存在返回的函数中——闭包<br>因为不是要计算值，只是要按需求值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br><span class="line">#每次调用都返回新函数</span><br><span class="line">&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f1==f2</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p><p><strong><em>返回函数引用局部变量时：不要引用循环变量，或后续发生变化的变量</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><p><strong>nonlocal</strong> 函数使用外层函数变量（局部变量）</p><p>#####装饰器<br>增强函数功能，又不改变函数定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br><span class="line">#等价于 now = log(now) 所以装饰器传参要定义三层</span><br><span class="line">&gt;&gt;&gt; now()</span><br><span class="line">call now():</span><br><span class="line">2015-3-25</span><br></pre></td></tr></table></figure></p><p>可传参装饰器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        #now.__name__ = &apos;wrapper&apos;，所以需要用下列函数改变now的名字，防止依赖函数名的代码出错</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2015-3-25&apos;)</span><br></pre></td></tr></table></figure></p><p>#####偏函数<br>在原函数的基础上固定传入参数，创建新函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> import functools</span><br><span class="line">&gt;&gt;&gt; int2 = functools.partial(int, base=2)</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</span><br><span class="line">64</span><br></pre></td></tr></table></figure></p><p>#####模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&apos; a test module &apos;</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Michael Liao&apos;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    if len(args)==1:</span><br><span class="line">        print(&apos;Hello, world!&apos;)</span><br><span class="line">    elif len(args)==2:</span><br><span class="line">        print(&apos;Hello, %s!&apos; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Too many arguments!&apos;)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure></p><p>第1行：使文件可以直接在Unix/Linux/Max上运行<br>第4行：文档注释，任何模块的第一行字符串都视为文档注释<br>第6行：加上作者<br>(不知道和setup.py里的注释有啥区别)<br><strong>name</strong>置为<strong>main</strong>：通过命令行执行额外代码，可用于测试</p><p>####类<br>创建类实例：<br><code>a = Account(“he”,1000) #调用 Account.__init__(“he”,1000)</code><br>作用域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">calss Animal(object):</span><br><span class="line">    def __init__(self,age):</span><br><span class="line">        self.age = age</span><br><span class="line">    def jump(self):</span><br><span class="line">        print(&quot;jump!&quot;)</span><br><span class="line">    def shut(self):</span><br><span class="line">        jump(self)    #error,类中没有作用域</span><br><span class="line">        self.jump()   #这样才能指向创建的实例</span><br></pre></td></tr></table></figure></p><p>继承：<br>class Dog(Animal):<br>    def <strong>init</strong>(self,age,name):    #<br>        Animal.<strong>init</strong>(self,age)   #初始化基类<br>        self.name = name<br>    def shut:<br>        print(“wang!”)</p><p>super():<br>    super.function()    #调用父类的方法，在继承的父类的方法中无新的实现</p><p>多继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A(object): pass</span><br><span class="line">class B(A): pass</span><br><span class="line">class C(A,B): pass</span><br></pre></td></tr></table></figure></p><p>严重的程序设计错误，基类列表中先搜索了A，但显然B比A特殊</p><p>鸭子类型：<br>Python对象的特征由对象的方法决定，而非父类，对于实现了同样方法，接口的对象，可以看作是相似类。例如，当一个方法需要传入一个类对象时，可以传入与该类相似的类对象，并不限定于该类的对象及子类。<br>实例可以绑定任意数据：a，b均继承A，a.extend = 2，但b并没有extend属性<br><strong>数据封装</strong>：在变量前面添加 __或者单下划线，双下划线的变量会被Python解释器改名，但这里确实没有什么机制限制你对私有变量的访问<br><strong>多态</strong>：鸭子类型<br><strong>isinstance</strong>：类型判断，可以判断是否是多类型中的一种  ([1, 2, 3], (list, tuple))<br><strong>实例属性&amp;类属性</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name = &apos;Student&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建实例s</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 打印类的name属性</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 给实例绑定name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问</span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name # 如果删除实例的name属性</span><br><span class="line">&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br><span class="line">Student</span><br></pre></td></tr></table></figure></p><p>#####<strong>slots</strong><br>限制实例能添加的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;) # 用tuple定义允许绑定的属性名称</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; s = Student() # 创建新的实例</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Michael&apos; # 绑定属性&apos;name&apos;</span><br><span class="line">&gt;&gt;&gt; s.age = 25 # 绑定属性&apos;age&apos;</span><br><span class="line">&gt;&gt;&gt; s.score = 99 # 绑定属性&apos;score&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos;</span><br></pre></td></tr></table></figure></p><h5 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h5><p>将类方法定义为属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value   </span><br><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)</span><br><span class="line">&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()</span><br><span class="line">60</span><br></pre></td></tr></table></figure></p><p>#####多重继承  MixIn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Mammal, Runnable):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><p>#####定制类<br>实现一些特定的方法使对象成为特定的类（鸭子类型思想）<br><strong><strong>getattr</strong></strong>：可以将类的属性和方法动态处理，这里有一个关于REST API的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Chain(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, path=&apos;&apos;):</span><br><span class="line">        self._path = path</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, path):</span><br><span class="line">        return Chain(&apos;%s/%s&apos; % (self._path, path))</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self._path</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; Chain().status.user.timeline.list</span><br><span class="line">&apos;/status/user/timeline/list&apos;</span><br></pre></td></tr></table></figure></p><p><strong><strong>call</strong></strong>：通过实例直接调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(&apos;My name is %s.&apos; % self.name)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s = Student(&apos;Michael&apos;)</span><br><span class="line">&gt;&gt;&gt; s() # self参数不要传入</span><br><span class="line">My name is Michael.</span><br><span class="line">#判断一个对象是否能被调用</span><br><span class="line">&gt;&gt;&gt; callable(Student())</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>#####使用枚举类<br>每个对象都是类的唯一实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 # Sun的value被设定为0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br></pre></td></tr></table></figure></p><p>#####元类<br><strong>metaclass</strong>：控制类的创建行为<br>ORM框架：使用者根据表结构定义出对应的类来（因此需要控制类的创建方式）<br>抽象出一层类的模板</p><p>####错误，调试，测试<br><strong>try…except…finally</strong><br><strong>raise</strong>：抛出错误</p><p><strong>assert</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    assert n != 0, &apos;n is zero!&apos;</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    foo(&apos;0&apos;)</span><br><span class="line">    </span><br><span class="line">$ python err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">AssertionError: n is zero!</span><br><span class="line"></span><br><span class="line">$ python -O err.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p><p><strong>logging</strong><br>允许指定信息级别，有debug，info，warning，error；level = INFO时，logging.debug失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br></pre></td></tr></table></figure></p><p><strong>pdb</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python -m pdb err.py</span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()</span><br><span class="line">-&gt; s = &apos;0&apos;</span><br><span class="line">(Pdb) l</span><br><span class="line">  1     # err.py</span><br><span class="line">  2  -&gt; s = &apos;0&apos;</span><br><span class="line">  3     n = int(s)</span><br><span class="line">  4     print(10 / n)</span><br></pre></td></tr></table></figure></p><p>输入命令n可以单步执行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) n</span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()</span><br><span class="line">-&gt; n = int(s)</span><br><span class="line">(Pdb) n</span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()</span><br><span class="line">-&gt; print(10 / n)</span><br></pre></td></tr></table></figure></p><p>任何时候都可以输入命令p 变量名来查看变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(Pdb) p s</span><br><span class="line">&apos;0&apos;</span><br><span class="line">(Pdb) p n</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p><p>输入命令q结束调试，退出程序：<br><code>(Pdb) q</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># err.py</span><br><span class="line">import pdb</span><br><span class="line"></span><br><span class="line">s = &apos;0&apos;</span><br><span class="line">n = int(s)</span><br><span class="line">pdb.set_trace() # 运行到这里会自动暂停</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure></p><p>运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python err.py </span><br><span class="line">&gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()</span><br><span class="line">-&gt; print(10 / n)</span><br><span class="line">(Pdb) p n</span><br><span class="line">0</span><br><span class="line">(Pdb) c</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    print(10 / n)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure></p><p>####IO编程</p><p>#####文件读写<br>for line in f.readlines():<br>    print(line.strip())<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(size)</span><br><span class="line">readlines()：适用配置文件，按行返回list</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#读二进制文件&apos;rb&apos;</span><br><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;,encoding=&apos;gbk&apos;,errors=&apos;ignore&apos;) as f:</span><br><span class="line">    print(f.read())</span><br><span class="line">#写文件</span><br><span class="line">#&apos;w&apos;：直接覆盖模式，&apos;a&apos;：追加模式</span><br><span class="line">with open(&apos;/Users/michael/test.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.write(&apos;Hello, world!&apos;)</span><br></pre></td></tr></table></figure><p>#####内存读写<br>在内存中操作str和bytes，提供一个和读取文件一样的接口<br>StringIO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO(&apos;Hello!\nHi!\nGoodbye!&apos;)</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     s = f.readline()</span><br><span class="line">...     if s == &apos;&apos;:</span><br><span class="line">...         break</span><br><span class="line">...     print(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure></p><p>BytesIO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; print(f.getvalue())</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br></pre></td></tr></table></figure></p><p>#####操作文件和目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.environ.get(&apos;PATH&apos;)</span><br><span class="line">&apos;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&apos;</span><br><span class="line">&gt;&gt;&gt; os.environ.get(&apos;x&apos;, &apos;default&apos;)</span><br><span class="line">&apos;default&apos;</span><br><span class="line"></span><br><span class="line"># 查看当前目录的绝对路径:</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line"># 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/michael&apos;, &apos;testdir&apos;)</span><br><span class="line">&apos;/Users/michael/testdir&apos;</span><br><span class="line"># 然后创建一个目录:</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"># 删掉一个目录:</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/michael/testdir&apos;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; os.path.split(&apos;/Users/michael/testdir/file.txt&apos;)</span><br><span class="line">(&apos;/Users/michael/testdir&apos;, &apos;file.txt&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#直接让你得到文件扩展名，很多时候非常方便：</span><br><span class="line">&gt;&gt;&gt; os.path.splitext(&apos;/path/to/file.txt&apos;)</span><br><span class="line">(&apos;/path/to/file&apos;, &apos;.txt&apos;)</span><br><span class="line"></span><br><span class="line"># 对文件重命名:</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line"># 删掉文件:</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br><span class="line"></span><br><span class="line">#列出当前目录下的所有目录，只需要一行代码：</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)]</span><br><span class="line">[&apos;.lein&apos;, &apos;.local&apos;, &apos;.m2&apos;, &apos;.npm&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;.vim&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, ...]</span><br><span class="line"></span><br><span class="line">#要列出所有的.py文件，也只需一行代码：</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1]==&apos;.py&apos;]</span><br><span class="line">[&apos;apis.py&apos;, &apos;config.py&apos;, &apos;models.py&apos;, &apos;pymonitor.py&apos;, &apos;test_db.py&apos;, &apos;urls.py&apos;, &apos;wsgiapp.py&apos;]</span><br></pre></td></tr></table></figure></p><p>#####序列化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b&apos;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">#反序列化</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; d = pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>#####JSON<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; d = dict(name=&apos;Bob&apos;, age=20, score=88)</span><br><span class="line">&gt;&gt;&gt; json.dumps(d)</span><br><span class="line">&apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">#反序列化</span><br><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; json.loads(json_str)</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>class转换为JSON<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#在类中定义一个将对象转为dict的函数</span><br><span class="line">def student2dict(std):</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;name&apos;: std.name,</span><br><span class="line">        &apos;age&apos;: std.age,</span><br><span class="line">        &apos;score&apos;: std.score</span><br><span class="line">    &#125;</span><br><span class="line">#default关键字指定转换函数</span><br><span class="line">&gt;&gt;&gt; print(json.dumps(s, default=student2dict))</span><br><span class="line">&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88&#125;</span><br><span class="line"></span><br><span class="line">#反序列化</span><br><span class="line">def dict2student(d):</span><br><span class="line">    return Student(d[&apos;name&apos;], d[&apos;age&apos;], d[&apos;score&apos;])</span><br><span class="line">运行结果如下：</span><br><span class="line">&gt;&gt;&gt; json_str = &apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))</span><br><span class="line">&lt;__main__.Student object at 0x10cd3c190&gt;</span><br></pre></td></tr></table></figure></p><p>常用的函数：<br>range(n) 生成0~n-1的序列<br>bool():return true or false<br>abs()  int()  float()  str()<br>isinstance(a,str) : 判断a是否是str类型<br>itemgetter函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3] </span><br><span class="line">&gt;&gt;&gt; b=operator.itemgetter(1)      //定义函数b，获取对象的第1个域的值</span><br><span class="line">&gt;&gt;&gt; b(a)</span><br></pre></td></tr></table></figure></p><p><strong>ThreadLocal</strong>：为线程绑定自己的全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建全局ThreadLocal对象:</span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line">def process_student():</span><br><span class="line">    # 获取当前线程关联的student:</span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">def process_thread(name):</span><br><span class="line">    # 绑定ThreadLocal的student:</span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(&apos;Alice&apos;,), name=&apos;Thread-A&apos;)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"></span><br><span class="line">#执行结果：</span><br><span class="line">Hello, Alice (in Thread-A)</span><br><span class="line">Hello, Bob (in Thread-B)</span><br></pre></td></tr></table></figure></p><p>####正则表达式<br>规则</p><ul><li><p>[0-9a-zA-Z_]可以匹配一个数字、字母或者下划线；</p></li><li><p>[0-9a-zA-Z_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如’a100’，’0_Z’，’Py3000’等等；</p></li><li><p>[a-zA-Z_][0-9a-zA-Z_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</p></li><li><p>[a-zA-Z_][0-9a-zA-Z_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p></li><li><p>A|B可以匹配A或B，所以(P|p)ython可以匹配’Python’或者’python’。</p></li><li><p>^表示行的开头，^\d表示必须以数字开头。</p></li><li><p>\$表示行的结束，\d\$表示必须以数字结束。</p></li></ul><p>re模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&apos;, &apos;010 12345&apos;)</span><br><span class="line">test = &apos;用户输入的字符串&apos;</span><br><span class="line">if re.match(r&apos;正则表达式&apos;, test):</span><br><span class="line">    print(&apos;ok&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;failed&apos;)</span><br></pre></td></tr></table></figure></p><h4 id="的使用"><a href="#的使用" class="headerlink" title="_ 的使用"></a>_ 的使用</h4><p>1.代表上一行执行的结果<br>2.分配一个特定名称(I don’t care the value of _)<br><figure class="highlight plain"><figcaption><span>_ in range(20):</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_something()</span><br></pre></td></tr></table></figure></p><p>3.实现国际化和本地化字符串之间翻译查找的函数名称<br><figure class="highlight plain"><figcaption><span>django.utils.translation import ugettext as _ </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse </span><br><span class="line">def my_view(request): </span><br><span class="line">    output = _(&quot;Welcome to my site.&quot;) </span><br><span class="line">    return HttpResponse(output)</span><br></pre></td></tr></table></figure></p><p><strong>名称前的单下划线*</strong><br>_myself : 被声明为私有变量，import时就不会引入该种变量，除非该变量在 <strong>all</strong>中显示出现<br><strong>名称前的双下划线*</strong><br>子类继承该方法后，并不能覆盖父类的方法，而是生成一个新方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A(object): </span><br><span class="line">... def _internal_use(self): </span><br><span class="line">... pass </span><br><span class="line">... def __method_name(self): </span><br><span class="line">... pass </span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; dir(A()) </span><br><span class="line">[&apos;_A__method_name&apos;, ..., &apos;_internal_use&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class B(A): </span><br><span class="line">... def __method_name(self): </span><br><span class="line">... pass </span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; dir(B()) </span><br><span class="line">[&apos;_A__method_name&apos;, &apos;_B__method_name&apos;, ..., &apos;_internal_use&apos;]</span><br></pre></td></tr></table></figure></p><p><strong>名称前后的双下划线（如：<strong>init</strong>）</strong><br>特殊方法名，如默认的构造函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###Python复习&lt;br&gt;@(Python小结)[摘自廖雪峰博客]&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;####基础&lt;/p&gt;
&lt;p&gt;#####编码方式：uincode&lt;br&gt;print 字符串，每遇到 ‘ , ‘自动换成空格&lt;br&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/11/20/net_problem/"/>
    <id>http://yoursite.com/2017/11/20/net_problem/</id>
    <published>2017-11-20T07:26:50.715Z</published>
    <updated>2018-03-18T14:15:35.318Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 无线连接问题<br>date: 2017-12-08 21:26:50</p><h2 id="tags-jottings"><a href="#tags-jottings" class="headerlink" title="tags: jottings"></a>tags: jottings</h2><h4 id="1-29-网页无法打开"><a href="#1-29-网页无法打开" class="headerlink" title="1.29 网页无法打开"></a>1.29 网页无法打开</h4><p>在这里就不得不吐槽一下了，从一月初发现自己笔记本域名解析出现问题，具体表现为：网页无法打开，但是qq等应用程序可以正常使用；怀疑是本地域名服务器出现了问题，按这个思路找了很多解决办法未果。之后又发现连接校园网的时候出现这个问题，但是连接手机热点却能正常访问网页，于是怀疑是校园网的原因。尝试多种解决办法无果后，借着自己手机流量多(就是懒)，便把问题搁置了。1.19回家之后就开始练车，到今天再次用电脑时，发现连家里的WiFi还是有同样问题。最后，这条命令：<br><strong>netsh winsock reset</strong><br>解决了这个磨人的问题。说是windows网络编程的接口是winsock,可能是安装软件的时候winsock的目录被修改，导致网络配置出错。即winsock与网络连接传输信息时参数被修改，导致无法发出正确请求无法获得正确响应。<br>综上：<br>问题：<br>1.笔记本无法打开网页，例如qq等的应用可以正常使用<br>2.该问题出现在笔记本链接WiFi时，当笔记本连接手机热点时问题消失<br>解决办法：<br>netsh winsock reset<br>我的看法：winsock是应用层协议，连接手机热点发出的包协议头部与连接wifi发出的包不同，当其目录被修改时导致接包方解析出错。</p><p>####3.4<br>续问题，电脑再次连接校园网出现问题。网页无法打开，qq正常运行。网络诊断dns服务器未检测到。当前域名服务器为8.8.8.8，Google可正常搜索，搜索到的内容也无法打开</p><p>####3.5<br>只支持有线网络上网</p><p>####3.15<br>学校限制外部DNS(之前因为域名服务器有问题，自己手动改过DNS)，导致无法连接上网。改为DNS服务器自动获取后，成功连上DLUT！！！这两天一直呆实验室或者机房，靠网线上网。。。<br>解决方法：因为实验室搭网线，来了一个小哥，他帮我瞬间能弄好的，简直无敌感谢他！<br>我的诟病：<br>    1.想法里有过正确的解决方式，但是因为暂时不可达性导致错过<br>    2.有问题不及时解决，不到非不得已就一直拖着<br>    3.缺少和别人的交流，模糊了互相帮助和有偿服务的界限<br>    4.对自己和别人的评价不能恰如其分<br>总之，大部分人的价值是在被别的人需要中体现的，所以乐于去帮助别人，也学会适当的寻求别人的帮助，不是一个人单枪匹马就叫英雄，你在群体中成长会更迅速。还有，排除了一切不可能，那么唯一剩下的这个可能性就是结果。不要再在事实面前自我迷惑了。</p><p>一旦出现错误，就开始怀疑自己所有工作，导致无法定位问题的源头</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 无线连接问题&lt;br&gt;date: 2017-12-08 21:26:50&lt;/p&gt;
&lt;h2 id=&quot;tags-jottings&quot;&gt;&lt;a href=&quot;#tags-jottings&quot; class=&quot;headerlink&quot; title=&quot;tags: jotti
      
    
    </summary>
    
    
  </entry>
  
</feed>
